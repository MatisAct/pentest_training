#[30 - Task 06] Cấu trúc dữ liệu
##các công việc cần làm 
 - **[1:Tìm hiểu về tuples, sets, dict](#1)**
 - **[2:Dịch bài  tại mục [urllib2.urlopen()](https://docs.python.org/2/library/urllib2.html)](#2)**
 - **[3:Dùng thư viện urllib2 để giải bài tập này [here](http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=12345)](#3)**
 
 
<a name="1"></a>
###1:Tìm hiểu về tuples, sets, dict

Trong Python, bộ dữ liệu là một phần của ngôn ngữ chuẩn. Đây là một cấu trúc dữ liệu rất giống với danh sách cấu trúc dữ liệu. Sự khác biệt chính là việc vận tuple là nhanh hơn so với danh sách vì các tuple là không thay đổi.
câu lệnh khai báo hàm :

Để tạo một tuple, nơi các giá trị được đặt trong  ngoặc vuông:
ví dụ:
```
>>>L  =  ( 1 ,  2 ,  3 ) 

>>>L[0]

1
```
Nó cũng có thể tạo ra một bộ mà không có dấu ngoặc đơn, bằng cách sử dụng dấu phẩy:

```
>>> L  =  1 ,  2 

>>> l 

(1, 2)
```
Nếu bạn muốn tạo ra một bộ với một yếu tố duy nhất, bạn phải sử dụng dấu phẩy:
```
>>> Singleton  =  ( 1 ,  )
```
Bạn có thể lặp lại một bộ dữ liệu bằng cách nhân một tuple của một số:
```
>>> ( 1 ,)  *  5 

(1, 1, 1, 1, 1)
```
Lưu ý rằng bạn có thể nối các tuple và sử dụng assignement Augmented ( * = , + =):
```

>>> S1  =  ( 1 , 0 ) 

>>> s1  + =  ( 1 ,) 

>>> s1 

(1, 0, 1)
```
**Dicts**
Dictionary trong Python là một tập hợp các cặp key và value không có thứ tự. Nó là một container mà chứa dữ liệu, được bao quanh bởi các dấu ngoặc móc đơn {}. Mỗi cặp key-value được xem như là một item. Key mà đã truyền cho item đó phải là duy nhất, trong khi đó value có thể là bất kỳ kiểu giá trị nào. Key phải là một kiểu dữ liệu không thay đổi (immutable) như chuỗi, số hoặc tuple.

Key và value được phân biệt riêng rẽ bởi một dấu hai chấm (:). Các item phân biệt nhau bởi một dấu phảy (,). Các item khác nhau được bao quanh bên trong một cặp dấu ngoặc móc đơn tạo nên một Dictionary trong Python

ví dụ:
```
data={100:'Hoang' ,101:'Nam' ,102:'Binh'}

print data 

>>> 
{100: 'Hoang', 101: 'Nam', 102: 'Binh'}
>>>
```

**Các thuộc tính của key trong Dictionary**
Không có hạn chế nào với các value trong Dictionary, tuy nhiên với key thì bạn cần chú ý các điểm sau:

(a) Nhiều hơn một entry cho mỗi key là không được phép. Nghĩa là không cho phép bản sao các key được xuất hiện. Khi bắt gặp nhiều bản sao key trong phép gán, thì phép gán cuối cùng được thực hiện. Ví dụ:

```
dict = {'Ten': 'Hoang', 'Tuoi': 7, 'Ten': 'Nam'};

print "dict['Ten']: ", dict['Ten']

>>>
 dict['Ten']:  Nam
```

**(b)** Key phải là immutable. Nghĩa là bạn chỉ có thể sử dụng chuỗi, số hoặc tuple làm key của Dictionary. Dưới đây là ví dụ đơn giản:

```
ict = {['Ten']: 'Hoang', 'Tuoi': 7};

print "dict['Ten']: ", dict['Ten']
```

kết quả 

```
Traceback (most recent call last):
 
  File "test.py", line 3, in <module>
 
    dict = {['Ten']: 'Hoang', 'Tuoi': 7};

TypeError: list objects are unhashable
```

**Truy cập các giá trị trong Dictionary trong Python**

Khi chỉ mục không được định nghĩa với Dictionary, thì các giá trị trong Dictionary có thể được truy cập thông qua các key của chúng. Cú pháp:

`<ten_dictionary>[key]`

Ví dụ:

```
data1={'Id':100, 'Ten':'Thanh', 'Nghenghiep':'Developer'}

data2={'Id':101, 'Ten':'Chinh', 'Nghenghiep':'Trainer'}

print "Id cua nhan vien dau tien la",data1['Id']

print "Id cua nhan vien thu hai la",data2['Id']

print "Ten cua nhan vien dau tien la:",data1['Ten']

print "Nghe nghiep cua nhan vien thu hai la:",data2['Nghenghiep']
```

Kết quả là:

```
>>> 
Id cua nhan vien dau tien la 100

Id cua nhan vien thu hai la 101

Ten cua nhan vien dau tien la is Thanh

Nghe nghiep cua nhan vien thu hai la Trainer
>>>
```

**Cập nhật Dictionary trong Python**
Item (cặp key-value) có thể được cập nhật. Bạn cập nhật một Dictionary bằng cách thêm một entry mới hoặc một cặp key-value mới, sửa đổi một entry đã tồn tại, hoặc xóa một entry đang tồn tại như trong ví dụ đơn giản sau:

```
data1={'Id':100, 'Ten':'Thanh', 'Nghenghiep':'Developer'}

data2={'Id':101, 'Ten':'Chinh', 'Nghenghiep':'Trainer'}

data1['Nghenghiep']='Manager'

data2['Mucluong']=17000000

data1['Mucluong']=12000000

print data1

print data2
```

Khi code trên được thực thi sẽ cho kết quả:

```
>>> 

{'Mucluong': 12000000, 'Nghenghiep': 'Manager','Id': 100, 'Ten': 'Thanh'}

{'Mucluong': 17000000, 'Nghenghiep': 'Trainer', 'Id': 101, 'Ten': 'Chinh'}

>>>
```

**Xóa phần tử từ Dictionary trong Python**
Với Dictionary, bạn có thể xóa một phần tử đơn hoặc xóa toàn bộ nội dung của Dictionary đó. Bạn sử dụng lệnh del để thực hiện các hoạt động này.

Cú pháp để xóa một item từ Dictionary:

`del ten_dictionary[key]`


**sets**.
Một tập hợp là một nhóm các phần tử không trùng lặp. Tập hợp thường được sử dụng để loại bỏ các phần tử trùng lặp trong danh sách, hay là dùng để kiểm tra nhân viên, hội viên....

cú pháp:

```
>>>a = ['a','b','a','d','c','d']

>>>taphop = set(a)

set(['a', 'c', 'b', 'd']) #nó đã bỏ đi các phần tử giống nhau

>>>'a' in taphop #kiểm tra xem a có phải phần tử của tập hợp không

True
```

Với kiểu dữ liệu tập hợp, chúng ta cũng có 4 toán tử tác động tới tập hợp: hợp, giao, hiệu, và hiệu đối xứng.

```

>>> a = set('abracadabra')

>>> b = set('alacazam')

>>> a                                  # những kí tự có trong a

set(['a', 'r', 'b', 'c', 'd'])

>>> a - b                              # kí tự có trong a nhưng không có trong b

set(['r', 'd', 'b'])

>>> a | b                              # kí tự có ở a hoặc b

set(['a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'])

>>> a & b                              # kí tự có cả ở a và b

set(['a', 'c'])

>>> a ^ b                              # kí tự có ở a hoặc b nhưng không có ở cả hai

set(['r', 'd', 'b', 'm', 'z', 'l'])
```

<a name="2"></a>
**2:Dịch bài  tại mục [urllib2.urlopen()](https://docs.python.org/2/library/urllib2.html)]**
 urllib2 —thư viện mở rộng cho việc mở URL
Các mô-đun urllib2 định nghĩa chức năng và các lớp học giúp cho việc mở các URL (chủ yếu là HTTP) trong một thế giới phức tạp - cơ bản và  xác thực, chuyển hướng, cookies và nhiều hơn nữa.
Các urllib2mô-đun định nghĩa các chức năng sau:
urllib2.urlopen(url[, data[, timeout[, cafile[, capath[, cadefault[, context]]]]]) 
Mở url URL, đó có thể là một chuỗi ký tự hay một đối tượng `Request` dữ liệu có thể là một chuỗi xác định dữ liệu bổ sung để gửi đến máy chủ.Hiện nay các yêu cầu `HTTP` là những người duy nhất sử dụng dữ liệu các yêu cầu `HTTP POST` sẽ là một thay vì một `GET` khi tham số dữ liệu được cung cấp. Dữ liệu cần có một bộ đệm trong `application / www.x--form-urlencoded` định dạng chuẩn Các `urllib.urlencode()` chức năng có một bản đồ hoặc chuỗi 2 bộ dữ liệu và trả về một chuỗi ở định dạng này. Module urllib2 gửi HTTP / 1.1 yêu cầu với `Connection:close` tiêu đề bao gồm.
Các thông số thời gian chờ tùy chọn chỉ định một thời gian chờ trong giây để chặn các hoạt động như các nỗ lực kết nối (nếu không quy định, thiết lập thời gian chờ mặc định toàn cầu sẽ được sử dụng). Điều này thực sự chỉ làm việc cho HTTP, HTTPS và FTP kết nối. 

Nếu bối cảnh được xác định, nó phải là một ví dụ `ssl.SSLContext` mô tả các tùy chọn SSL khác nhau. Xem `HTTPSConnection` để biết thêm chi tiết. 

Các CAFile và capath thông số tùy chọn chỉ định một tập hợp các chứng chỉ CA đáng tin cậy cho các yêu cầu HTTPS. CAFile phải trỏ đến một tập tin duy nhất có chứa một gói giấy chứng nhận CA, trong khi capath phải trỏ đến một thư mục của file chứng băm. Thông tin chi tiết có thể được tìm thấy trong `ssl.SSLContext.load_verify_locations ()`. 

Các thông số cadefault được bỏ qua. 

Hàm này trả về một đối tượng tập tin giống như với ba phương pháp bổ sung:

- `geturl()` - Trả lại URL của tài nguyên lấy ra, thường được sử dụng để xác định xem một chuyển hướng đã được theo sau

- `info()`- Trả lại siêu thông tin của trang, như tiêu đề, trong các hình thức của một `mimetools.Message` ví dụ (xem tham khảo nhanh đến HTTP Headers )

- `getcode()` - Trả về mã trạng thái HTTP của đáp ứng.

Lưu ý rằng None có thể được trả lại nếu không xử lý xử lý các yêu cầu (mặc dù mặc định cài đặt toàn cầu OpenerDirectorsử dụng UnknownHandlerđể đảm bảo điều này không bao giờ xảy ra).

Ngoài ra, nếu cài đặt proxy được phát hiện (ví dụ, khi một *_proxy biến môi trường nhưhttp_proxyđược thiết lập), ProxyHandlerlà mặc định cài đặt và đảm bảo các yêu cầu được xử lý thông qua proxy.

Thay đổi trong phiên bản 2.6: thời gian chờ được thêm vào.

Thay đổi trong phiên bản 2.7.9: CAFile , capath , cadefault , và bối cảnh đã được thêm vào.
**urllib2.install_opener( Mở )**

Cài đặt một `OpenerDirector` ví dụ như mở toàn cầu mặc định. Cài đặt một cái mở chỉ cần thiết nếu bạn muốn sử dụng urlopen mở rằng; nếu không, chỉ cần gọi `OpenerDirector.open()` thay vì `urlopen()` . Các mã không kiểm tra một thực tế `OpenerDirector`, và bất kỳ lớp học với giao diện thích hợp sẽ làm việc.

**urllib2.build_opener([handler, ...])**


Quay trở lại một `OpenerDirector` ví dụ, trong đó chuỗi các xử lý theo thứ tự nhất định. `Handler` s  có thể là trường hợp của `BaseHandler`, hoặc các 

lớp con của `BaseHandler` (trong trường hợp đó phải được thể gọi constructor không có tham số). Trường hợp các lớp sau sẽ ở phía trước của bộ xử lý s, 

trừ khi xử lý s chứa chúng, trường hợp của họ hay các lớp con của họ: ProxyHandler(nếu cài đặt proxy được phát hiện)

Nếu việc cài đặt python có hỗ trợ SSL (tức là nếu module ssl có thể được cho biết) `HTTPSHandler` cũng được thêm vô.

Bắt đầu với python bản 2.3,1 `BaseHandler` lớp con cũng có thể thay đổi thuộc tính `handlerorder` để sửa đổi vị trí của nó trong danh sách xử lý.
Các trường hợp ngoại lệ sau đây được nâng lên cho phù hợp:

ngoại lệ `urllib2.URLError`
Việc xử lý nâng cao ngoại lệ này (hoặc trường hợp ngoại lệ có nguồn gốc) khi họ chạy vào một vấn đề. Nó là một lớp con của IOError.

reason
Lý do cho lỗi này. Nó có thể là một chuỗi tin nhắn hoặc một ví dụ ngoại lệ ( socket.errorđối với các URL từ xa, OSErrorcho URL địa phương).

ngoại lệ `urllib2.HTTPError`

Mặc dù là một ngoại lệ (một lớp con của URLError), một HTTPError cũng có chức năng như một giá trị trả về tập tin giống như không ngoại lệ (điều tương 

tự mà urlopen()trả về). Điều này rất hữu ích khi xử lý lỗi HTTP kỳ lạ, chẳng hạn như yêu cầu để xác thực.

code

Một mã trạng thái HTTP như được định nghĩa trong RFC 2616 . Giá trị số này tương ứng với một giá trị được tìm thấy trong từ điển của mã như được tìm 

thấy trong BaseHTTPServer.BaseHTTPRequestHandler.responses.

reason

Lý do cho lỗi này. Nó có thể là một chuỗi tin nhắn hoặc dụ một ngoại lệ.

Các lớp học sau đây được cung cấp:

lớp urllib2.Request( url [, dữ liệu] [, tiêu đề] [, origin_req_host] [, chưa được kiểm chứng] ) 

Lớp này là một sự trừu tượng của một yêu cầu URL.

url phải là một chuỗi có chứa một URL hợp lệ.

dữ liệu có thể là một chuỗi xác định dữ liệu bổ sung để gửi đến máy chủ, hoặc Nonenếu không có dữ liệu như vậy là cần thiết. Hiện nay các yêu cầu HTTP là những người duy nhất sử dụng dữ liệu ; các yêu cầu HTTP POST sẽ là một thay vì một GET khi dữ liệu tham số được cung cấp. dữ liệu nên có một bộ đệm trong các tiêu chuẩn application / x-www-form-urlencoded định dạng. Các urllib.urlencode()chức năng có một bản đồ hoặc chuỗi 2 bộ dữ liệu và trả về một chuỗi ở định dạng này.

tiêu đề phải là một từ điển, và sẽ được đối xử như thể add_header() được gọi với mỗi phím và giá trị như các đối số. Điều này thường được sử dụng để "giả mạo" các User-Agentgiá trị tiêu đề, được sử dụng bởi một trình duyệt để xác định chính nó - một số máy chủ HTTP chỉ cho phép yêu cầu đến từ các trình duyệt phổ biến như trái ngược với các kịch bản. Ví dụ, Mozilla Firefox có thể xác định chính nó như là , trong khi của chuỗi tác nhân người dùng mặc định là (trên Python 2.6)."Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 Firefox/2.0.0.11"urllib2"Python-urllib/2.6"

Hai đối số cuối cùng là chỉ quan tâm để xử lý đúng của HTTP cookies của bên thứ ba:

origin_req_host nên yêu cầu chủ nhà của các giao dịch có nguồn gốc, theo định nghĩa củaRFC 2965 . Nó mặc địnhcookielib.request_host(self). Đây là tên máy chủ hoặc địa chỉ IP của các yêu cầu ban đầu được khởi xướng bởi người sử dụng. Ví dụ, nếu yêu cầu là một hình ảnh trong một tài liệu HTML, điều này nên được yêu cầu chủ nhà của các yêu cầu cho các trang có chứa hình ảnh.

chưa được kiểm chứng nên chỉ xem yêu cầu là chưa được kiểm chứng, như được định nghĩa bởi RFC 2965. Nó mặc định False. Một yêu cầu chưa được kiểm chứng là có URL mà người dùng không có tùy chọn để phê duyệt. Ví dụ, nếu yêu cầu là một hình ảnh trong một tài liệu HTML, và người sử dụng không có tùy chọn để duyệt quyến rũ hình ảnh tự động, điều này phải được sự thật.

lớp urllib2.OpenerDirector

Các OpenerDirectorlớp mở URL qua BaseHandlers xích lại với nhau. Nó quản lý các xâu chuỗi các xử lý và phục hồi từ lỗi.

lớp urllib2.BaseHandler

Đây là lớp cơ sở cho tất cả các xử lý đăng ký - và chỉ kiểm soát các cơ chế đơn giản đăng ký.

lớp urllib2.HTTPDefaultErrorHandler

Một lớp định nghĩa một hàm xử lý mặc định cho báo xử lý lỗi HTTP; tất cả các câu trả lời được biến thành HTTPErrortrường hợp ngoại lệ.

lớp urllib2.HTTPRedirectHandler

Một lớp học để xử lý chuyển hướng.

lớp urllib2.HTTPCookieProcessor( [ cookiejar ] ) 

Một lớp học để xử lý Cookie HTTP.

lớp urllib2.ProxyHandler( [ proxy ] ) 

Yêu cầu nguyên nhân phải đi qua một proxy. Nếu proxy được đưa ra, nó phải là một từ điển tên giao thức lập bản đồ các URL của các proxy. Mặc định là để đọc danh sách các proxy từ các biến môi trường <protocol>_proxy. Nếu không có biến môi trường proxy được thiết lập, sau đó trong một môi trường Windows cài đặt proxy được lấy từ phần Cài đặt Internet của registry, và trong một môi trường thông tin proxy Mac OS X được lấy từ X System Configuration Khung OS.

Để tắt proxy autodetected vượt qua một từ điển rỗng.

chú thích HTTP_PROXYsẽ bị bỏ qua nếu một biến REQUEST_METHODđược thiết lập; xem tài liệu trên getproxies().
lớp urllib2.HTTPPasswordMgr
Giữ một cơ sở dữ liệu của các ánh xạ.(realm, uri) -> (user, password)

lớp urllib2.HTTPPasswordMgrWithDefaultRealm
Giữ một cơ sở dữ liệu của các ánh xạ. Một lĩnh vực được coi là một nhận tất cả lĩnh vực, mà là tìm kiếm nếu không có lĩnh vực khác phù hợp.(realm, uri) -> (user, password)None

lớp urllib2.AbstractBasicAuthHandler( [ password_mgr ] ) 
Đây là một lớp mixin giúp với xác thực HTTP, cả đến các máy chủ từ xa và đến một proxy. Password_mgr , nếu được, nên có cái gì đó là tương thích với HTTPPasswordMgr; xem phần Objects HTTPPasswordMgr cho thông tin trên giao diện phải được hỗ trợ.

lớp urllib2.HTTPBasicAuthHandler( [ password_mgr ] ) 
Xử lý xác thực với máy chủ từ xa. Password_mgr , nếu được, nên có cái gì đó là tương thích với HTTPPasswordMgr; xem phần Objects HTTPPasswordMgr cho thông tin trên giao diện phải được hỗ trợ.

lớp `urllib2.ProxyBasicAuthHandler( [ password_mgr ] )` 
Xử lý xác thực với các proxy. Password_mgr , nếu được, nên có cái gì đó là tương thích với HTTPPasswordMgr; xem phần Objects HTTPPasswordMgr cho thông tin trên giao diện phải được hỗ trợ.

lớp `urllib2.AbstractDigestAuthHandler( [ password_mgr ] ) `
Đây là một lớp mixin giúp với xác thực HTTP, cả đến các máy chủ từ xa và đến một proxy. Password_mgr , nếu được, nên có cái gì đó là tương thích với HTTPPasswordMgr; xem phần Objects HTTPPasswordMgr cho thông tin trên giao diện phải được hỗ trợ.

lớp `urllib2.HTTPDigestAuthHandler( [ password_mgr ] )` 
Xử lý xác thực với máy chủ từ xa. Password_mgr , nếu được, nên có cái gì đó là tương thích với HTTPPasswordMgr; xem phần Objects HTTPPasswordMgr cho thông tin trên giao diện phải được hỗ trợ.

lớp `urllib2.ProxyDigestAuthHandler( [ password_mgr ] )` 
Xử lý xác thực với các proxy. Password_mgr , nếu được, nên có cái gì đó là tương thích với HTTPPasswordMgr; xem phần Objects HTTPPasswordMgr cho thông tin trên giao diện phải được hỗ trợ.

lớp `urllib2.HTTPHandler`
Một lớp học để xử lý mở HTTP URL.

lớp` urllib2.HTTPSHandler` ( [ debuglevel [ , bối cảnh ] ] ) 
Một lớp học để xử lý mở `HTTPS URL`. Bối cảnh có ý nghĩa tương tự như đối httplib.HTTPSConnection.

Thay đổi trong phiên bản 2.7.9: bối cảnh gia tăng.

lớp `urllib2.FileHandler`
Mở tập tin địa phương.

lớp `urllib2.FTPHandler`
URL FTP mở.

lớp `urllib2.CacheFTPHandler`
Mở URL FTP, giữ một bộ nhớ cache của các kết nối FTP mở để giảm thiểu sự chậm trễ.

lớp `urllib2.UnknownHandler`
Một nhận tất cả các lớp để xử lý các URL chưa biết.

lớp `urllib2.HTTPErrorProcessor`
Quá trình phản ứng lỗi HTTP.

<a name="3"></a>
###[3:Dùng thư viện urllib2 để giải bài tập này [here](http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=12345)]

đầu tiên khi truy cập nào [đây](http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=12345)

hiển thị ngay 

<img src="http://image.prntscr.com/image/c080075b23db48249bbdd381a3ea692f.png">

ở đây ta thấy chỉ có dòng

`and the next nothing is 44827`

ta thử thay đổi trên `URL` 12345 bằng 44827


<img src="http://image.prntscr.com/image/94be6e1437ce45f3b50a5845aa3b9f67.png">
thì lại xuất hiện dòng `and the next nothing is 45439`

tiếp tục thử 1 vài lần không có gì thay đổi, mà theo chỉ dận task 6 phải dùng thư viện `urllib2` để giải , mà thư viện này lại liên quan tới `URL`  nhìn kỹ lại `URL` ta thấy chỉ thay đổi dãy số thì không có gì thay đổi! nhìn kỹ lại 1 lần nữa thì ta thấy  !

**http://www.pythonchallenge.com/pc/def/linkedlist.php?`nothing=44827`**

từ `nothing=` từ đầu đến giờ ta chỉ thay đổi day~ số mà không thay đổi luôn đoạn này , giờ ta thử xóa đoạn `nothing=`

<img src="http://image.prntscr.com/image/4d178faa818340d799a3c6addba7a7b3.png">

done ! 

**p/s em không biết làm thế này có đúng ý anh không , nếu không để e tìm cách  khác làm lại ạ!
với lại bài này e làm theo cảm tính  hên nên qua ạ!**

